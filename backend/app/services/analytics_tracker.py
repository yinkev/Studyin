"""Analytics event tracking service.

Centralized service for tracking all analytics events.
Usage:
    from app.services.analytics_tracker import tracker

    await tracker.track_event(
        user_id=user.id,
        session_id=session_id,
        event_type="question_submit",
        properties={"is_correct": True}
    )
"""

from __future__ import annotations

import logging
from datetime import datetime
from typing import Any, Optional
from uuid import UUID

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.analytics_events import (
    EventTypeEnum,
    MaterialInteraction,
    QuestionAttempt,
    StudyEvent,
    StudySession,
)

logger = logging.getLogger(__name__)


class AnalyticsTracker:
    """Service for tracking analytics events.

    Handles:
    - Event validation
    - Writing to study_events table
    - Updating session aggregates
    - Creating attempt/interaction records
    - Error handling and logging
    """

    async def track_event(
        self,
        db: AsyncSession,
        user_id: UUID,
        session_id: UUID,
        event_type: str,
        material_id: Optional[UUID] = None,
        chunk_id: Optional[UUID] = None,
        question_id: Optional[UUID] = None,
        topic_id: Optional[UUID] = None,
        properties: Optional[dict[str, Any]] = None,
        client_ip: Optional[str] = None,
        user_agent: Optional[str] = None,
        device_type: Optional[str] = None,
    ) -> StudyEvent:
        """Track a study event.

        Args:
            db: Database session
            user_id: User UUID
            session_id: Study session UUID
            event_type: Type of event (see EventTypeEnum)
            material_id: Material UUID (optional)
            chunk_id: Chunk UUID (optional)
            question_id: Question UUID (optional)
            topic_id: Topic UUID (optional)
            properties: Event-specific metadata (optional)
            client_ip: Client IP address (optional, hashed for privacy)
            user_agent: User agent string (optional)
            device_type: Device type: web/mobile/tablet (optional)

        Returns:
            Created StudyEvent

        Raises:
            ValueError: If event_type is invalid
            SQLAlchemyError: If database write fails
        """
        # Validate event type
        try:
            EventTypeEnum(event_type)
        except ValueError:
            logger.warning(f"Invalid event type: {event_type}")
            raise ValueError(f"Invalid event type: {event_type}")

        # Create event
        event = StudyEvent(
            user_id=user_id,
            session_id=session_id,
            event_type=event_type,
            event_timestamp=datetime.utcnow(),
            material_id=material_id,
            chunk_id=chunk_id,
            question_id=question_id,
            topic_id=topic_id,
            properties=properties or {},
            client_ip=self._anonymize_ip(client_ip) if client_ip else None,
            user_agent=user_agent,
            device_type=device_type,
        )

        try:
            db.add(event)
            await db.commit()
            await db.refresh(event)

            logger.info(
                f"Tracked event: {event_type} for user {user_id} in session {session_id}"
            )
            return event

        except Exception as e:
            await db.rollback()
            logger.error(f"Failed to track event: {e}", exc_info=True)
            raise

    async def track_session_start(
        self,
        db: AsyncSession,
        user_id: UUID,
        session_id: UUID,
        device_type: str = "web",
        user_agent: Optional[str] = None,
    ) -> tuple[StudyEvent, StudySession]:
        """Track session start and create session record.

        Args:
            db: Database session
            user_id: User UUID
            session_id: Session UUID (generated by caller)
            device_type: Device type
            user_agent: User agent string

        Returns:
            Tuple of (StudyEvent, StudySession)
        """
        # Track event
        event = await self.track_event(
            db=db,
            user_id=user_id,
            session_id=session_id,
            event_type=EventTypeEnum.SESSION_START,
            device_type=device_type,
            user_agent=user_agent,
            properties={"device_type": device_type},
        )

        # Create session record
        session = StudySession(
            id=session_id,
            user_id=user_id,
            started_at=datetime.utcnow(),
            is_active=True,
            device_type=device_type,
        )
        db.add(session)
        await db.commit()
        await db.refresh(session)

        logger.info(f"Session started: {session_id} for user {user_id}")
        return event, session

    async def track_session_end(
        self,
        db: AsyncSession,
        user_id: UUID,
        session_id: UUID,
    ) -> tuple[StudyEvent, StudySession]:
        """Track session end and finalize session record.

        Args:
            db: Database session
            user_id: User UUID
            session_id: Session UUID

        Returns:
            Tuple of (StudyEvent, StudySession)
        """
        # Get session
        result = await db.execute(select(StudySession).where(StudySession.id == session_id))
        session = result.scalar_one_or_none()

        if not session:
            raise ValueError(f"Session not found: {session_id}")

        # Calculate duration
        session.ended_at = datetime.utcnow()
        session.duration_seconds = int((session.ended_at - session.started_at).total_seconds())
        session.is_active = False

        # Track event
        event = await self.track_event(
            db=db,
            user_id=user_id,
            session_id=session_id,
            event_type=EventTypeEnum.SESSION_END,
            properties={
                "duration_seconds": session.duration_seconds,
                "active_seconds": session.active_seconds,
                "materials_viewed": session.materials_viewed,
                "questions_attempted": session.questions_attempted,
                "xp_earned": session.xp_earned,
            },
        )

        await db.commit()
        await db.refresh(session)

        logger.info(f"Session ended: {session_id} ({session.duration_seconds}s)")
        return event, session

    async def track_question_attempt(
        self,
        db: AsyncSession,
        user_id: UUID,
        session_id: UUID,
        question_id: UUID,
        topic_id: UUID,
        selected_answer: str,
        correct_answer: str,
        time_to_answer_seconds: int,
        confidence_level: Optional[int] = None,
        hint_used: bool = False,
    ) -> tuple[StudyEvent, QuestionAttempt]:
        """Track question attempt with full metadata.

        Args:
            db: Database session
            user_id: User UUID
            session_id: Session UUID
            question_id: Question UUID
            topic_id: Topic UUID
            selected_answer: User's answer (e.g., "A")
            correct_answer: Correct answer (e.g., "B")
            time_to_answer_seconds: Time spent
            confidence_level: User confidence 1-5 (optional)
            hint_used: Whether hint was used

        Returns:
            Tuple of (StudyEvent, QuestionAttempt)
        """
        is_correct = selected_answer == correct_answer

        # Check if first attempt
        result = await db.execute(
            select(QuestionAttempt)
            .where(QuestionAttempt.user_id == user_id)
            .where(QuestionAttempt.question_id == question_id)
        )
        previous_attempts = result.scalars().all()
        is_first = len(previous_attempts) == 0
        attempt_number = len(previous_attempts) + 1

        # Calculate days since last attempt
        days_since_last = None
        if previous_attempts:
            last_attempt = max(previous_attempts, key=lambda a: a.attempted_at)
            delta = datetime.utcnow() - last_attempt.attempted_at
            days_since_last = delta.total_seconds() / 86400

        # Track event
        event = await self.track_event(
            db=db,
            user_id=user_id,
            session_id=session_id,
            event_type=EventTypeEnum.QUESTION_SUBMIT,
            question_id=question_id,
            topic_id=topic_id,
            properties={
                "selected_answer": selected_answer,
                "correct_answer": correct_answer,
                "is_correct": is_correct,
                "time_to_answer_seconds": time_to_answer_seconds,
                "is_first_attempt": is_first,
                "attempt_number": attempt_number,
                "hint_used": hint_used,
            },
        )

        # Create attempt record
        attempt = QuestionAttempt(
            user_id=user_id,
            session_id=session_id,
            question_id=question_id,
            topic_id=topic_id,
            attempted_at=datetime.utcnow(),
            time_to_answer_seconds=time_to_answer_seconds,
            is_correct=is_correct,
            confidence_level=confidence_level,
            selected_answer=selected_answer,
            correct_answer=correct_answer,
            is_first_attempt=is_first,
            attempt_number=attempt_number,
            days_since_last_attempt=days_since_last,
            hint_used=hint_used,
        )
        db.add(attempt)

        # Update session metrics
        result = await db.execute(select(StudySession).where(StudySession.id == session_id))
        session = result.scalar_one_or_none()
        if session:
            session.questions_attempted += 1
            if is_correct:
                session.questions_correct += 1

        await db.commit()
        await db.refresh(attempt)

        logger.info(
            f"Question attempt: {question_id} by user {user_id} - "
            f"{'correct' if is_correct else 'incorrect'} (attempt {attempt_number})"
        )

        return event, attempt

    async def track_material_interaction(
        self,
        db: AsyncSession,
        user_id: UUID,
        session_id: UUID,
        material_id: UUID,
        topic_id: Optional[UUID],
        interaction_type: str,
        chunk_id: Optional[UUID] = None,
        duration_seconds: int = 0,
        scroll_depth_percent: Optional[int] = None,
        is_complete: bool = False,
    ) -> tuple[StudyEvent, MaterialInteraction]:
        """Track material interaction (read, highlight, note, bookmark).

        Args:
            db: Database session
            user_id: User UUID
            session_id: Session UUID
            material_id: Material UUID
            topic_id: Topic UUID (optional)
            interaction_type: Type: read/highlight/note/bookmark
            chunk_id: Chunk UUID (optional)
            duration_seconds: Time spent
            scroll_depth_percent: Scroll depth 0-100
            is_complete: Whether fully completed

        Returns:
            Tuple of (StudyEvent, MaterialInteraction)
        """
        # Track event
        event = await self.track_event(
            db=db,
            user_id=user_id,
            session_id=session_id,
            event_type=EventTypeEnum.MATERIAL_READ,
            material_id=material_id,
            chunk_id=chunk_id,
            topic_id=topic_id,
            properties={
                "interaction_type": interaction_type,
                "duration_seconds": duration_seconds,
                "scroll_depth_percent": scroll_depth_percent,
                "is_complete": is_complete,
            },
        )

        # Find or create interaction record
        result = await db.execute(
            select(MaterialInteraction)
            .where(MaterialInteraction.user_id == user_id)
            .where(MaterialInteraction.session_id == session_id)
            .where(MaterialInteraction.material_id == material_id)
            .where(MaterialInteraction.chunk_id == chunk_id)
        )
        interaction = result.scalar_one_or_none()

        if interaction:
            # Update existing
            interaction.duration_seconds += duration_seconds
            interaction.revisit_count += 1
            if scroll_depth_percent:
                interaction.scroll_depth_percent = max(
                    interaction.scroll_depth_percent or 0, scroll_depth_percent
                )
            if is_complete:
                interaction.is_complete = True
                interaction.ended_at = datetime.utcnow()
        else:
            # Create new
            interaction = MaterialInteraction(
                user_id=user_id,
                session_id=session_id,
                material_id=material_id,
                chunk_id=chunk_id,
                topic_id=topic_id,
                interaction_type=interaction_type,
                started_at=datetime.utcnow(),
                duration_seconds=duration_seconds,
                scroll_depth_percent=scroll_depth_percent,
                is_complete=is_complete,
            )
            db.add(interaction)

        # Update session metrics
        result = await db.execute(select(StudySession).where(StudySession.id == session_id))
        session = result.scalar_one_or_none()
        if session:
            if interaction_type == "read":
                session.chunks_read += 1
            if is_complete:
                session.materials_completed += 1

        await db.commit()
        await db.refresh(interaction)

        logger.info(
            f"Material interaction: {material_id} by user {user_id} - "
            f"{interaction_type} ({duration_seconds}s)"
        )

        return event, interaction

    def _anonymize_ip(self, ip: str) -> str:
        """Anonymize IP address for privacy.

        Args:
            ip: IP address

        Returns:
            Truncated/hashed IP
        """
        # IPv4: Remove last octet (192.168.1.123 → 192.168.1.0)
        # IPv6: Remove last 64 bits
        if "." in ip:  # IPv4
            parts = ip.split(".")
            return ".".join(parts[:3] + ["0"])
        elif ":" in ip:  # IPv6
            parts = ip.split(":")
            return ":".join(parts[:4] + ["0000"] * 4)
        return ip


# Global tracker instance
tracker = AnalyticsTracker()
